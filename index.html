<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Cyber Bird">
  <meta name="description" content="A cyberpunk-themed Flappy Bird game with neon visuals and smooth animations. Fly through the neon cityscape!">
  <meta name="keywords" content="flappy bird, cyberpunk, neon, game, html5">
  <title>Cyber Bird - Neon Flight</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Sixtyfour&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <style>
    body {
      margin: 0;
      height: 100vh;
      background: linear-gradient(135deg, #1a0a1f 0%, #0f0515 30%, #0a030a 60%, #000000 100%);
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #0ff;
      overflow: hidden;
      text-shadow: 0 0 8px #0ff;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.15) 1px, transparent 0),
        radial-gradient(circle at 2px 2px, rgba(0, 0, 0, 0.2) 1px, transparent 0),
        radial-gradient(circle at 3px 3px, rgba(255, 255, 255, 0.1) 1px, transparent 0);
      background-size: 4px 4px, 3px 3px, 5px 5px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
      mix-blend-mode: overlay;
    }
    .code-stream {
      position: fixed;
      left: 20px;
      top: 0;
      width: 60px;
      height: 100%;
      font-size: 9px;
      color: rgba(200, 200, 200, 0.25);
      font-family: 'Share Tech Mono', monospace;
      line-height: 1.3;
      overflow: hidden;
      z-index: 1;
    }
    .code-stream::before {
      content: '0x1A2B\A 0x3C4D\A 0x5E6F\A 0x7890\A 0xABCD\A 0xEF01\A 0x2345\A 0x6789\A 0xFEDC\A 0xBA98\A 0x7654\A 0x3210\A 0x9ABC\A 0xDEF0\A 0x1234\A 0x5678\A 0x9ABC\A 0xDEF0\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF\A 0x0246\A 0x8ACE\A 0x1357\A 0x9BDF\A 0x2468\A 0xACE0\A 0x1357\A 0x9BDF';
      white-space: pre;
      display: block;
    }
    .text-artifacts {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.15;
    }
    .text-artifacts::before {
      content: 'FLIGHT_SYS\A ALTITUDE_OK\A COLLISION_AVOID\A SPEED_NOM\A NAV_ACTIVE\A SIGNAL_STRONG\A PROTOCOL_ENABLED\A LINK_ESTABLISHED\A DATA_STREAM\A PACKET_SENT\A ACK_RECEIVED\A ROUTE_OPTIMAL\A CONNECTION_STABLE\A BUFFER_CLEAR\A QUEUE_EMPTY';
      position: absolute;
      top: 10%;
      left: 15%;
      font-size: 7px;
      color: rgba(150, 150, 150, 0.35);
      font-family: 'Share Tech Mono', monospace;
      white-space: pre;
      line-height: 1.4;
      transform: rotate(-1.5deg);
    }
    .geometric-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.2;
    }
    .geometric-lines::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, rgba(0, 245, 255, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(0, 245, 255, 0.1) 1px, transparent 1px);
      background-size: 50px 50px, 50px 50px;
      background-position: 0 0, 0 0;
    }
    .game-title {
      position: fixed;
      top: 40px;
      left: 80px;
      z-index: 100;
      pointer-events: none;
    }
    .game-title-main {
      font-size: 25px;
      font-weight: normal;
      color: #ffeb3b;
      text-shadow: 
        2px 2px 0 #00f5ff,
        0 0 4px rgba(0, 245, 255, 0.4),
        0 0 8px rgba(255, 235, 59, 0.8);
      letter-spacing: 2px;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-bottom: 5px;
      filter: drop-shadow(0 0 6px rgba(255, 235, 59, 0.5));
    }
    .game-title-sub {
      font-size: 20px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 
        0 0 8px #ff6b35,
        0 0 15px rgba(255, 107, 53, 0.5);
      letter-spacing: 4px;
      font-family: 'Share Tech Mono', monospace;
      text-transform: uppercase;
      line-height: 1;
      margin-left: 2px;
    }
    .top-controls {
      position: fixed;
      top: 20px;
      right: 80px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
    }
    .game-controls {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      z-index: 100;
    }
    #restart {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: all 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    #restart .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    #restart:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #restart.glitch {
      animation: glitch 0.3s ease-in-out;
    }
    @keyframes glitch {
      0%, 100% {
        transform: translate(0);
        filter: hue-rotate(0deg);
      }
      10% {
        transform: translate(-2px, 2px);
        filter: hue-rotate(90deg);
      }
      20% {
        transform: translate(-2px, -2px);
        filter: hue-rotate(180deg);
      }
      30% {
        transform: translate(2px, 2px);
        filter: hue-rotate(270deg);
      }
      40% {
        transform: translate(2px, -2px);
        filter: hue-rotate(360deg);
      }
      50% {
        transform: translate(-2px, 2px);
        filter: hue-rotate(90deg);
      }
      60% {
        transform: translate(-2px, -2px);
        filter: hue-rotate(180deg);
      }
      70% {
        transform: translate(2px, 2px);
        filter: hue-rotate(270deg);
      }
      80% {
        transform: translate(-2px, -2px);
        filter: hue-rotate(360deg);
      }
      90% {
        transform: translate(2px, 2px);
        filter: hue-rotate(90deg);
      }
    }
    #soundBtn {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: all 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    #soundBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    #soundBtn:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #soundBtn.muted {
      opacity: 0.5;
    }
    #pauseBtn {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: all 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    #pauseBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    #pauseBtn:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    #pauseBtn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    #game-container {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
      margin-top: 80px;
    }
    canvas {
      background: rgba(10, 10, 30, 0.3);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
      border: 2px solid rgba(0, 245, 255, 0.75);
      border-radius: 12px;
      display: block;
      touch-action: none;
      transition: all 0.1s ease;
    }
    canvas.glitch {
      animation: canvasGlitch 0.3s ease-in-out;
    }
    @keyframes canvasGlitch {
      0%, 100% {
        border-color: rgba(0, 245, 255, 0.75);
        box-shadow: 0 0 20px rgba(0, 245, 255, 0.5), 0 0 40px rgba(255, 0, 255, 0.3), inset 0 0 12px rgba(0, 245, 255, 0.3);
        filter: hue-rotate(0deg);
      }
      10% {
        border-color: rgba(255, 235, 59, 0.9);
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.8), 0 0 50px rgba(255, 107, 53, 0.5), inset 0 0 15px rgba(255, 235, 59, 0.5);
        filter: hue-rotate(90deg);
      }
      20% {
        border-color: rgba(255, 107, 53, 0.9);
        box-shadow: 0 0 25px rgba(255, 107, 53, 0.8), 0 0 45px rgba(0, 245, 255, 0.5), inset 0 0 18px rgba(255, 107, 53, 0.5);
        filter: hue-rotate(180deg);
      }
      30% {
        border-color: rgba(0, 245, 255, 0.9);
        box-shadow: 0 0 35px rgba(0, 245, 255, 0.9), 0 0 55px rgba(255, 235, 59, 0.6), inset 0 0 20px rgba(0, 245, 255, 0.6);
        filter: hue-rotate(270deg);
      }
      40% {
        border-color: rgba(255, 235, 59, 0.9);
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.8), 0 0 50px rgba(255, 107, 53, 0.5), inset 0 0 15px rgba(255, 235, 59, 0.5);
        filter: hue-rotate(360deg);
      }
      50% {
        border-color: rgba(255, 107, 53, 0.9);
        box-shadow: 0 0 25px rgba(255, 107, 53, 0.8), 0 0 45px rgba(0, 245, 255, 0.5), inset 0 0 18px rgba(255, 107, 53, 0.5);
        filter: hue-rotate(90deg);
      }
      60% {
        border-color: rgba(0, 245, 255, 0.9);
        box-shadow: 0 0 35px rgba(0, 245, 255, 0.9), 0 0 55px rgba(255, 235, 59, 0.6), inset 0 0 20px rgba(0, 245, 255, 0.6);
        filter: hue-rotate(180deg);
      }
      70% {
        border-color: rgba(255, 235, 59, 0.9);
        box-shadow: 0 0 30px rgba(255, 235, 59, 0.8), 0 0 50px rgba(255, 107, 53, 0.5), inset 0 0 15px rgba(255, 235, 59, 0.5);
        filter: hue-rotate(270deg);
      }
      80% {
        border-color: rgba(255, 107, 53, 0.9);
        box-shadow: 0 0 25px rgba(255, 107, 53, 0.8), 0 0 45px rgba(0, 245, 255, 0.5), inset 0 0 18px rgba(255, 107, 53, 0.5);
        filter: hue-rotate(360deg);
      }
      90% {
        border-color: rgba(0, 245, 255, 0.9);
        box-shadow: 0 0 35px rgba(0, 245, 255, 0.9), 0 0 55px rgba(255, 235, 59, 0.6), inset 0 0 20px rgba(0, 245, 255, 0.6);
        filter: hue-rotate(90deg);
      }
    }
    .score-display {
      position: relative;
      z-index: 20;
      text-align: center;
      pointer-events: none;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }
    .score-display strong {
      font-size: 32px;
      color: #00f5ff;
      text-shadow: 0 0 10px #00f5ff, 0 0 20px rgba(0, 245, 255, 0.5);
      font-family: 'Share Tech Mono', monospace;
    }
    .lives-display {
      font-size: 14px;
      color: #ff6b35;
      text-shadow: 0 0 6px #ff6b35;
      font-family: 'Share Tech Mono', monospace;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .lives-display .material-icons {
      font-family: 'Material Icons';
      font-size: 16px;
      color: inherit;
    }
    .lives-display .material-icons.greyed {
      color: #666666;
      text-shadow: none;
      opacity: 0.5;
    }
    .high-score-system {
      position: fixed;
      bottom: 40px;
      right: 80px;
      z-index: 100;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      color: rgba(150, 150, 150, 0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .high-score-system::before {
      content: '[SYS] ';
      color: rgba(0, 245, 255, 0.5);
    }
    .high-score-system strong {
      color: rgba(0, 245, 255, 0.7);
      font-weight: normal;
    }
    #gameOver {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      pointer-events: none;
      border-radius: 12px;
    }
    #gameOver.show {
      display: flex;
    }
    .game-over-content {
      text-align: center;
      pointer-events: auto;
    }
    .flatlined-text {
      font-size: 72px;
      font-weight: bold;
      color: #ff0040;
      text-shadow: 
        0 0 4px rgba(255, 0, 64, 0.8),
        0 0 10px rgba(255, 0, 64, 0.48),
        0 0 18px rgba(255, 0, 64, 0.32),
        0 0 28px rgba(255, 0, 64, 0.24),
        0 0 40px rgba(255, 0, 64, 0.16);
      margin-bottom: 20px;
      letter-spacing: 8px;
      filter: brightness(1.1);
    }
    .game-over-subtitle {
      font-size: 24px;
      color: #ff0040;
      text-shadow: 0 0 10px #ff0040;
      margin-bottom: 30px;
    }
    .final-score {
      font-size: 42px;
      color: #00f5ff;
      text-shadow: 0 0 15px #00f5ff;
      margin-bottom: 40px;
    }
    #restartGame {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 20px;
      padding: 15px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
    }
    #restartGame:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px #ffeb3b;
      transform: scale(1.1);
      text-shadow: 0 0 15px #ffeb3b;
    }
    #menuBtn {
      background: transparent;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 28px;
      width: 44px;
      height: 44px;
      padding: 0;
      cursor: pointer;
      text-shadow: 0 0 6px #00f5ff;
      transition: all 0.2s ease;
      border: none;
      outline: none;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }
    #menuBtn .material-icons {
      font-family: 'Material Icons';
      font-size: 28px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    #menuBtn:hover {
      text-shadow: 0 0 10px #00f5ff;
      transform: scale(1.1);
    }
    .menu-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 17, 0.95);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
      padding: 120px 20px 20px 20px;
      box-sizing: border-box;
    }
    .menu-modal.show {
      display: flex;
    }
    .menu-content {
      background: rgba(10, 10, 30, 0.95);
      border: 2px solid #00f5ff;
      border-radius: 12px;
      padding: 0;
      max-width: 700px;
      max-height: 80vh;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.5);
      width: 90%;
      position: relative;
      box-sizing: border-box;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .menu-section {
      margin-bottom: 40px;
    }
    .menu-section:last-child {
      margin-bottom: 0;
    }
    .menu-section-title {
      font-size: 24px;
      color: #ffeb3b;
      text-shadow: 0 0 10px #ffeb3b;
      margin: 0;
      font-family: 'Sixtyfour', monospace;
      text-transform: uppercase;
      text-align: center;
      padding-bottom: 10px;
    }
    .menu-options {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-top: 20px;
    }
    .menu-option {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 18px;
      padding: 20px 40px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 15px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    .menu-option .material-icons {
      font-family: 'Material Icons';
      font-size: 24px;
      color: inherit;
      line-height: 1;
      display: inline-block;
    }
    .menu-option:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px #ffeb3b;
      text-shadow: 0 0 15px #ffeb3b;
      transform: scale(1.05);
    }
    .menu-screen {
      display: none;
      position: relative;
      flex: 1;
      overflow: hidden;
      flex-direction: column;
    }
    .menu-screen.active {
      display: flex;
    }
    .menu-header {
      flex-shrink: 0;
      padding: 40px 40px 20px 40px;
      border-bottom: 1px solid rgba(0, 245, 255, 0.3);
      position: relative;
    }
    .menu-scrollable {
      flex: 1;
      overflow-y: auto;
      padding: 20px 40px 40px 40px;
    }
    .menu-back {
      background: transparent;
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 8px #00f5ff;
      box-shadow: 0 0 10px #00f5ff;
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      width: fit-content;
    }
    .menu-back:hover {
      background: rgba(0, 245, 255, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 20px #ffeb3b;
      text-shadow: 0 0 15px #ffeb3b;
    }
    .menu-text {
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 6px #00f5ff;
      line-height: 1.8;
      margin-bottom: 15px;
      font-family: 'Share Tech Mono', monospace;
    }
    .menu-text strong {
      color: #ffeb3b;
      text-shadow: 0 0 8px #ffeb3b;
    }
    .setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 15px 0;
      border-bottom: 1px solid rgba(0, 245, 255, 0.2);
      min-height: 50px;
    }
    .setting-item:last-child {
      border-bottom: none;
    }
    .setting-label {
      font-size: 16px;
      color: #00f5ff;
      text-shadow: 0 0 6px #00f5ff;
      font-family: 'Share Tech Mono', monospace;
    }
    .toggle-switch {
      position: relative;
      width: 60px;
      height: 30px;
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00f5ff;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
      align-self: center;
    }
    .toggle-switch.active {
      background: rgba(0, 245, 255, 0.3);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.5);
    }
    .toggle-switch::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 2px;
      width: 22px;
      height: 22px;
      background: #00f5ff;
      border-radius: 50%;
      transition: all 0.3s ease;
      box-shadow: 0 0 8px #00f5ff;
      transform: translateY(-50%);
    }
    .toggle-switch.active::after {
      left: 32px;
      background: #ffeb3b;
      box-shadow: 0 0 8px #ffeb3b;
    }
    .setting-input {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .setting-input input[type="number"] {
      background: rgba(0, 0, 0, 0.5);
      border: 2px solid #00f5ff;
      color: #00f5ff;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      padding: 8px 12px;
      width: 80px;
      text-align: center;
      border-radius: 4px;
      text-shadow: 0 0 6px #00f5ff;
      box-shadow: 0 0 10px rgba(0, 245, 255, 0.3);
    }
    .setting-input input[type="number"]:focus {
      outline: none;
      border-color: #ffeb3b;
      box-shadow: 0 0 15px rgba(255, 235, 59, 0.5);
      color: #ffeb3b;
    }
    .reset-highscore {
      background: transparent;
      border: 2px solid #ff6b6b;
      color: #ff6b6b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 14px;
      padding: 8px 20px;
      cursor: pointer;
      text-shadow: 0 0 8px #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
    }
    .reset-highscore:hover {
      background: rgba(255, 107, 107, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 20px rgba(255, 235, 59, 0.5);
      text-shadow: 0 0 15px #ffeb3b;
    }
    .reset-settings {
      background: transparent;
      border: 2px solid #ff6b6b;
      color: #ff6b6b;
      font-family: 'Share Tech Mono', monospace;
      font-size: 16px;
      padding: 12px 30px;
      cursor: pointer;
      text-shadow: 0 0 8px #ff6b6b;
      box-shadow: 0 0 15px rgba(255, 107, 107, 0.3);
      transition: all 0.3s ease;
      border-radius: 6px;
      text-transform: uppercase;
      margin-top: 20px;
      width: 100%;
    }
    .reset-settings:hover {
      background: rgba(255, 107, 107, 0.1);
      color: #ffeb3b;
      border-color: #ffeb3b;
      box-shadow: 0 0 25px rgba(255, 235, 59, 0.5);
      text-shadow: 0 0 15px #ffeb3b;
    }
    @media (max-width: 768px) {
      .game-title {
        top: 15px;
        left: 15px;
      }
      .game-title-main {
        font-size: 18px;
      }
      .game-title-sub {
        font-size: 14px;
        letter-spacing: 2px;
      }
      .top-controls {
        top: 10px;
        right: 15px;
        gap: 10px;
      }
      #menuBtn, #soundBtn {
        width: 36px;
        height: 36px;
      }
      #menuBtn .material-icons, #soundBtn .material-icons {
        font-size: 24px;
      }
      #game-container {
        margin-top: 60px;
      }
      .game-controls {
        margin-bottom: 5px;
      }
      #restart, #pauseBtn, #menuBtn, #soundBtn {
        width: 36px;
        height: 36px;
      }
      #restart .material-icons, #pauseBtn .material-icons, #menuBtn .material-icons, #soundBtn .material-icons {
        font-size: 24px;
      }
      .high-score-system {
        bottom: 15px;
        right: 15px;
        font-size: 12px;
      }
      .code-stream, .text-artifacts {
        display: none;
      }
      .score-display strong {
        font-size: 24px;
      }
      .flatlined-text {
        font-size: 48px;
      }
      .game-over-subtitle {
        font-size: 18px;
      }
      #restartGame {
        font-size: 16px;
        padding: 12px 30px;
      }
      .start-title {
        font-size: 32px;
      }
      .start-instructions {
        font-size: 14px;
        padding: 0 20px;
      }
      .menu-modal {
        padding: 80px 15px 15px 15px;
      }
      .menu-content {
        width: calc(100% - 30px);
        max-width: calc(100% - 30px);
        padding: 0;
        max-height: calc(100vh - 30px);
      }
      .menu-header {
        padding: 25px 20px 15px 20px;
      }
      .menu-scrollable {
        padding: 15px 20px 25px 20px;
      }
    }
    button {
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      user-select: none;
      -webkit-user-select: none;
    }
    body {
      overscroll-behavior-y: contain;
    }
  </style>
</head>
<body>
  <div class="game-title">
    <div class="game-title-main">Cyber</div>
    <div class="game-title-sub">Bird</div>
  </div>
  <div class="code-stream"></div>
  <div class="text-artifacts"></div>
  <div class="geometric-lines"></div>
  <div class="top-controls">
    <button id="soundBtn" title="Toggle Sound"><span class="material-icons">volume_up</span></button>
    <button id="menuBtn" title="Menu"><span class="material-icons">menu</span></button>
  </div>
  <div id="game-container">
    <div class="game-controls">
      <button id="restart" title="Restart"><span class="material-icons">refresh</span></button>
      <div class="score-display">
        <strong id="score">0</strong>
        <div class="lives-display" id="livesDisplay">
          <span class="material-icons">favorite</span>
        </div>
      </div>
      <button id="pauseBtn" title="Pause/Play"><span class="material-icons">pause</span></button>
    </div>
    <canvas id="game"></canvas>
    <div class="menu-modal" id="menuModal">
      <div class="menu-content">
        <!-- Main Menu Screen -->
        <div class="menu-screen active" id="mainMenuScreen">
          <div class="menu-header">
            <div class="menu-section-title">MENU</div>
            <div class="menu-options">
              <button class="menu-option" id="howToPlayBtn">
                <span class="material-icons">help_outline</span>
                <span>HOW TO PLAY</span>
              </button>
              <button class="menu-option" id="settingsBtn">
                <span class="material-icons">settings</span>
                <span>SETTINGS</span>
              </button>
            </div>
          </div>
          <div class="menu-scrollable">
            <!-- No scrollable content for main menu -->
          </div>
        </div>

        <!-- How to Play Screen -->
        <div class="menu-screen" id="howToPlayScreen">
          <div class="menu-header">
            <button class="menu-back" id="backFromHowToPlay">← BACK</button>
            <div class="menu-section-title">HOW TO PLAY</div>
          </div>
          <div class="menu-scrollable">
            <div class="menu-text">
              <strong>Objective:</strong> Fly through the neon cityscape and avoid obstacles!
            </div>
            <div class="menu-text">
              <strong>Controls:</strong><br>
              • <strong>SPACE</strong> or <strong>CLICK/TAP</strong> - Make the bird fly up<br>
              • <strong>ENTER</strong> - Pause/Resume the game<br>
              • The bird will fall due to gravity if you don't keep it flying
            </div>
            <div class="menu-text">
              <strong>Scoring:</strong><br>
              • Score points by passing through obstacles<br>
              • Try to beat your high score!
            </div>
            <div class="menu-text">
              <strong>Tips:</strong><br>
              • Don't fly too high or too low<br>
              • Time your jumps carefully<br>
              • Practice makes perfect!
            </div>
          </div>
        </div>

        <!-- Settings Screen -->
        <div class="menu-screen" id="settingsScreen">
          <div class="menu-header">
            <button class="menu-back" id="backFromSettings">← BACK</button>
            <div class="menu-section-title">SETTINGS</div>
          </div>
          <div class="menu-scrollable">
            <div class="setting-item">
              <span class="setting-label">Enable Pipes</span>
              <div class="toggle-switch active" id="pipesToggle"></div>
            </div>
            <div class="setting-item">
              <span class="setting-label">Pipe Spacing</span>
              <div class="setting-input">
                <input type="number" id="pipeSpacingInput" min="150" max="500" step="10" value="250">
                <span style="color: #00f5ff; font-family: 'Share Tech Mono', monospace;">px</span>
              </div>
            </div>
            <div class="setting-item">
              <span class="setting-label">Pipe Gap</span>
              <div class="setting-input">
                <input type="number" id="pipeGapInput" min="100" max="300" step="10" value="180">
                <span style="color: #00f5ff; font-family: 'Share Tech Mono', monospace;">px</span>
              </div>
            </div>
            <div class="setting-item">
              <span class="setting-label">Pipe Speed</span>
              <div class="setting-input">
                <input type="number" id="pipeSpeedInput" min="1" max="10" step="0.5" value="3">
                <span style="color: #00f5ff; font-family: 'Share Tech Mono', monospace;">px/frame</span>
              </div>
            </div>
            <div class="setting-item">
              <span class="setting-label">Lives</span>
              <div class="setting-input">
                <input type="number" id="livesInput" min="1" max="10" step="1" value="1">
              </div>
            </div>
            <div class="setting-item">
              <span class="setting-label">Ghost Duration</span>
              <div class="setting-input">
                <input type="number" id="ghostDurationInput" min="500" max="5000" step="100" value="3000">
                <span style="color: #00f5ff; font-family: 'Share Tech Mono', monospace;">ms</span>
              </div>
            </div>
            <div class="setting-item" style="border-bottom: none; padding-bottom: 0;">
              <span class="setting-label">High Score</span>
              <button class="reset-highscore" id="resetHighscore">RESET</button>
            </div>
            <button class="reset-settings" id="resetSettings">RESET ALL SETTINGS</button>
          </div>
        </div>
      </div>
    </div>
    <div id="gameOver">
      <div class="game-over-content">
        <div class="flatlined-text">CRASHED</div>
        <div class="game-over-subtitle">SYSTEM FAILURE DETECTED</div>
        <div class="final-score">
          Score: <span id="finalScore">0</span>
        </div>
        <button id="restartGame">REBOOT SYSTEM</button>
      </div>
    </div>
  </div>
  <div class="high-score-system">
    HIGH SCORE: <strong id="highscore">0</strong>
  </div>
  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const highscoreEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const gameOverEl = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const restartGameBtn = document.getElementById('restartGame');
    const pauseBtn = document.getElementById('pauseBtn');
    const menuBtn = document.getElementById('menuBtn');
    const menuModal = document.getElementById('menuModal');
    const pipesToggle = document.getElementById('pipesToggle');
    const mainMenuScreen = document.getElementById('mainMenuScreen');
    const howToPlayScreen = document.getElementById('howToPlayScreen');
    const settingsScreen = document.getElementById('settingsScreen');
    const howToPlayBtn = document.getElementById('howToPlayBtn');
    const settingsBtn = document.getElementById('settingsBtn');
    const backFromHowToPlay = document.getElementById('backFromHowToPlay');
    const backFromSettings = document.getElementById('backFromSettings');
    const pipeSpacingInput = document.getElementById('pipeSpacingInput');
    const pipeGapInput = document.getElementById('pipeGapInput');
    const pipeSpeedInput = document.getElementById('pipeSpeedInput');
    const livesInput = document.getElementById('livesInput');
    const livesDisplay = document.getElementById('livesDisplay');
    const ghostDurationInput = document.getElementById('ghostDurationInput');
    const resetSettingsBtn = document.getElementById('resetSettings');
    const resetHighscoreBtn = document.getElementById('resetHighscore');

    // Game constants
    const GRAVITY = 0.5;
    const JUMP_STRENGTH = -8;
    const BIRD_SIZE = 30;
    const PIPE_WIDTH = 60;
    
    // Default pipe settings
    const DEFAULT_PIPE_SPEED = 3;
    const DEFAULT_PIPE_GAP = 180;
    const DEFAULT_PIPE_SPACING = 250;
    
    // Pipe settings (can be changed in settings)
    let pipeSpeed = DEFAULT_PIPE_SPEED;
    let pipeGap = DEFAULT_PIPE_GAP;
    let pipeSpacing = DEFAULT_PIPE_SPACING;

    // Game state
    let gameState = 'paused'; // 'paused', 'playing', 'falling', 'gameover'
    let pipesEnabled = true; // Setting to enable/disable pipes
    let maxLives = 1; // Default number of lives
    let currentLives = 1; // Current lives remaining
    let ghostDuration = 3000; // Default ghost duration in milliseconds (3 seconds)
    let bird = {
      x: 100,
      y: 250,
      velocity: 0,
      rotation: 0,
      wingAngle: 30,
      wingFlapping: false,
      wingFlapDecay: 0,
      glitching: false,
      ghosting: false,
      ghostEndTime: 0,
      blinking: false,
      blinkStartTime: 0,
      nextBlinkTime: 0
    };
    let pipes = [];
    let score = 0;
    let highscore = 0;
    const savedHighscore = localStorage.getItem('highscore');
    if (savedHighscore !== null && !isNaN(parseInt(savedHighscore))) {
      highscore = parseInt(savedHighscore);
    }
    let frameCount = 0;
    let animationFrame = 0;
    let lastTime = performance.now();
    let backgroundOffset = 0; // Parallax offset for background
    const PARALLAX_FACTOR = 0.4; // Background moves at 40% of pipe speed for parallax effect
    let cityscapeOffset = 0; // Parallax offset for cityscape
    const CITYSCAPE_PARALLAX_FACTOR = 0.7; // Cityscape moves at 70% of pipe speed (between stars and pipes)
    let groundOffset = 0; // Ground scrolling offset
    let cityscapeBuildings = []; // Array to store cityscape building data
    let cityscapeStreetLights = []; // Array to store street lights
    let cityscapeBillboards = []; // Array to store billboards
    let planes = []; // Array to store planes
    let lastPlaneSpawn = 0; // Last time a plane was spawned
    const PLANE_SPAWN_INTERVAL = 8000; // Spawn a plane every 8 seconds
    const PLANE_SPEED = 6; // Pixels per frame (increased for faster movement)
    let lastWindowUpdate = 0; // Last time windows were updated
    const WINDOW_UPDATE_INTERVAL = 2000; // Update windows every 2 seconds
    const GROUND_HEIGHT = 20; // Height of the ground element
    let groundPatternCanvas = null; // Cached pattern canvas for performance
    let groundPatternCached = false; // Flag to check if pattern is cached
    let starPositions = []; // Array to store random star positions
    let spaceHeld = false;
    let mouseHeld = false;
    let lastJumpTime = 0;
    const JUMP_INTERVAL = 150; // milliseconds between jumps when held
    
    // Cached gradients for performance
    let cachedPipeGradient = null;
    let cachedPipeCapGradientPassed = null;
    let cachedPipeCapGradientUnpassed = null;
    let cachedBirdGradient = null;
    let cachedSkyGradient = null;
    let cachedBuildingGradient = null;

    // Canvas setup
    function resizeCanvas() {
      const maxWidth = Math.min(500, window.innerWidth - 40);
      const maxHeight = Math.min(700, window.innerHeight - 200);
      const size = Math.min(maxWidth, maxHeight);
      
      canvas.width = size;
      canvas.height = size * 1.4;
      canvas.style.width = size + 'px';
      canvas.style.height = (size * 1.4) + 'px';
      
      // Reset bird position
      bird.y = canvas.height / 2;
      
      // Invalidate ground pattern cache when canvas resizes
      groundPatternCached = false;
      // Regenerate star positions when canvas resizes
      initializeStarPositions();
      // Regenerate cityscape when canvas resizes
      cityscapeBuildings = [];
      cityscapeStreetLights = [];
      cityscapeBillboards = [];
      initializeCityscape();
    }
    
    // Initialize random star positions
    function initializeStarPositions() {
      starPositions = [];
      const wrapWidth = canvas.width + 200;
      for (let i = 0; i < 100; i++) { // Increased from 50 to 100 for denser stars
        starPositions.push({
          baseX: Math.random() * wrapWidth,
          y: Math.random() * canvas.height
        });
      }
    }
    
    // Initialize cityscape buildings
    function initializeCityscape() {
      cityscapeBuildings = [];
      cityscapeStreetLights = [];
      cityscapeBillboards = [];
      const groundY = canvas.height - GROUND_HEIGHT;
      const wrapWidth = canvas.width * 2; // Wider wrap for cityscape
      
      // Billboard text options and fonts (defined once for consistency)
      const billboardTexts = ['CYBERBIRD', 'FLY AWAY', 'BE FREE', 'Glow', 'Be Nova', 'Neonworld', 'City of Dreams', 'Mox', 'Gigs Available', 'Auto Fixer'];
      const billboardFonts = [
        { family: 'Arial', weight: 'bold', style: 'normal' },
        { family: 'Courier New', weight: 'bold', style: 'normal' },
        { family: 'Impact', weight: 'normal', style: 'normal' },
        { family: 'Verdana', weight: 'bold', style: 'normal' },
        { family: 'Georgia', weight: 'bold', style: 'normal' },
        { family: 'Arial', weight: 'normal', style: 'italic' },
        { family: 'Courier New', weight: 'normal', style: 'normal' },
        { family: 'Arial', weight: '900', style: 'normal' }
      ];
      
      // Create buildings across the wrap width
      let currentX = 0;
      while (currentX < wrapWidth) {
        const buildingWidth = 40 + Math.random() * 60; // 40-100px wide
        const buildingHeight = 80 + Math.random() * (groundY - 150); // Vary heights
        const buildingX = currentX;
        const buildingY = groundY - buildingHeight;
        
        // Create building with details
        const building = {
          x: buildingX,
          y: buildingY,
          width: buildingWidth,
          height: buildingHeight,
          windows: [],
          neonSigns: [],
          hasNeonTop: Math.random() > 0.7 // 30% chance of neon top
        };
        
        // Add windows (grid pattern)
        const windowRows = Math.floor(buildingHeight / 25);
        const windowCols = Math.floor(buildingWidth / 15);
        const neonColors = ['#00f5ff', '#ff00ff', '#ffff00', '#00ff88', '#ff6b35'];
        for (let row = 0; row < windowRows; row++) {
          for (let col = 0; col < windowCols; col++) {
            if (Math.random() > 0.3) { // 70% chance of window
              const isNeon = Math.random() > 0.85; // 15% chance of neon window
              const windowObj = {
                x: buildingX + 5 + col * 15,
                y: buildingY + 5 + row * 25,
                lit: Math.random() > 0.5, // Random lit/unlit windows
                neon: isNeon // Some windows are neon
              };
              if (isNeon) {
                // Assign a random neon color to neon windows
                windowObj.neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
              }
              building.windows.push(windowObj);
            }
          }
        }
        
        // Add neon signs (some buildings) - vibrant neon colors
        if (Math.random() > 0.6) { // 40% of buildings have signs
          const signY = buildingY + buildingHeight * 0.3;
          // Random neon colors: cyan, magenta, yellow, green, orange
          const neonColors = ['#00f5ff', '#ff00ff', '#ffff00', '#00ff88', '#ff6b35'];
          const randomColor = neonColors[Math.floor(Math.random() * neonColors.length)];
          building.neonSigns.push({
            x: buildingX + buildingWidth * 0.2,
            y: signY,
            width: buildingWidth * 0.6,
            height: 8,
            color: randomColor // Vibrant neon colors
          });
        }
        
        cityscapeBuildings.push(building);
        currentX += buildingWidth + (Math.random() * 20); // Space between buildings
        
        // Add billboards occasionally (between buildings)
        if (Math.random() > 0.7) { // 30% chance of billboard
          const billboardX = currentX - (Math.random() * 10);
          const billboardWidth = 40 + Math.random() * 30; // 40-70px wide
          const billboardHeight = 25 + Math.random() * 15; // 25-40px tall
          const neonColors = ['#00f5ff', '#ff00ff', '#ffff00', '#00ff88', '#ff6b35'];
          cityscapeBillboards.push({
            x: billboardX,
            y: groundY - billboardHeight - 5, // Slightly above ground
            width: billboardWidth,
            height: billboardHeight,
            color: neonColors[Math.floor(Math.random() * neonColors.length)],
            text: billboardTexts[Math.floor(Math.random() * billboardTexts.length)],
            font: billboardFonts[Math.floor(Math.random() * billboardFonts.length)]
          });
        }
      }
      
      // Add equally spaced street lights along the bottom
      const streetLightSpacing = 60; // Space between street lights
      const neonColors = ['#00f5ff', '#ffff00', '#ff00ff'];
      for (let x = 0; x < wrapWidth; x += streetLightSpacing) {
        const lightHeight = 35 + Math.random() * 10; // 35-45px tall (slight variation)
        cityscapeStreetLights.push({
          x: x,
          y: groundY - lightHeight,
          height: lightHeight,
          color: neonColors[Math.floor(Math.random() * neonColors.length)]
        });
      }
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      // Clear cached gradients on resize since canvas dimensions change
      cachedSkyGradient = null;
      cachedBuildingGradient = null;
      resizeCanvas();
    });

    // Create cached ground pattern for performance
    function createGroundPattern() {
      const patternSpacing = 20;
      const patternWidth = patternSpacing;
      const patternHeight = GROUND_HEIGHT;
      
      // Create offscreen canvas for pattern (make it wide enough for seamless tiling)
      const patternCanvas = document.createElement('canvas');
      const patternWidthPixels = patternSpacing * 10; // Cache 10 patterns for seamless tiling
      patternCanvas.width = patternWidthPixels;
      patternCanvas.height = GROUND_HEIGHT;
      const patternCtx = patternCanvas.getContext('2d');
      
      // Draw pattern on cached canvas
      patternCtx.strokeStyle = '#00f5ff';
      patternCtx.lineWidth = 2;
      patternCtx.shadowColor = '#00f5ff';
      patternCtx.shadowBlur = 4;
      patternCtx.globalAlpha = 0.5;
      
      // Draw all ">" patterns
      patternCtx.beginPath();
      for (let i = 0; i < 10; i++) {
        const patternX = i * patternSpacing;
        const centerY = patternHeight * 0.5;
        const topY = 0;
        const bottomY = patternHeight;
        
        // Draw ">" shape
        patternCtx.moveTo(patternX, topY);
        patternCtx.lineTo(patternX + patternWidth * 0.5, centerY);
        patternCtx.lineTo(patternX, bottomY);
      }
      patternCtx.stroke();
      
      groundPatternCanvas = patternCanvas;
      groundPatternCached = true;
    }

    // Sound Manager
    const SoundManager = {
      audioContext: null,
      enabled: true,
      hasUserInteracted: false,
      
      init() {
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const soundPref = localStorage.getItem('soundEnabled');
          this.enabled = soundPref === null ? true : soundPref === 'true';
          this.updateButton();
        } catch (e) {
          console.warn('Web Audio API not supported:', e);
          this.enabled = false;
        }
      },
      
      updateButton() {
        const soundBtn = document.getElementById('soundBtn');
        if (soundBtn) {
          const icon = soundBtn.querySelector('.material-icons');
          if (icon) {
            if (this.enabled) {
              soundBtn.classList.remove('muted');
              icon.textContent = 'volume_up';
            } else {
              soundBtn.classList.add('muted');
              icon.textContent = 'volume_off';
            }
          }
        }
      },
      
      async ensureResumed() {
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') {
          if (!this.hasUserInteracted) return;
          try {
            await this.audioContext.resume();
          } catch (e) {}
        }
      },
      
      toggle() {
        this.enabled = !this.enabled;
        localStorage.setItem('soundEnabled', this.enabled.toString());
        this.updateButton();
        if (this.enabled) {
          this.playFlap();
        }
      },
      
      async playTone(frequency, duration, type = 'sine', volume = 0.3) {
        if (!this.enabled || !this.audioContext) return;
        if (this.audioContext.state === 'suspended' && !this.hasUserInteracted) return;
        await this.ensureResumed();
        if (this.audioContext.state === 'suspended') return;
        
        try {
          const now = this.audioContext.currentTime;
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);
          
          oscillator.type = type;
          oscillator.frequency.value = frequency;
          
          gainNode.gain.setValueAtTime(0.0001, now);
          gainNode.gain.exponentialRampToValueAtTime(volume, now + 0.003);
          gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration);
          
          oscillator.start(now);
          oscillator.stop(now + duration);
        } catch (e) {}
      },
      
      async playFlap() {
        await this.ensureResumed();
        this.playTone(400, 0.1, 'sine', 0.2);
      },
      
      async playScore() {
        await this.ensureResumed();
        this.playTone(523.25, 0.15, 'sine', 0.25);
        setTimeout(() => {
          this.playTone(659.25, 0.15, 'sine', 0.25);
        }, 100);
      },
      
      async playCrash() {
        await this.ensureResumed();
        const frequencies = [300, 250, 200, 150];
        frequencies.forEach((freq, index) => {
          setTimeout(() => {
            this.playTone(freq, 0.2, 'sawtooth', 0.3);
          }, index * 100);
        });
      },
      
      async playReboot() {
        await this.ensureResumed();
        // Power-on glitch sound effect
        this.playTone(200, 0.05, 'square', 0.2);
        setTimeout(() => {
          this.playTone(150, 0.05, 'square', 0.2);
        }, 50);
        setTimeout(() => {
          this.playTone(250, 0.1, 'sawtooth', 0.25);
        }, 100);
        setTimeout(() => {
          this.playTone(300, 0.15, 'sine', 0.3);
        }, 200);
      }
    };

    SoundManager.init();

    // Resume audio on user interaction
    let audioContextResumed = false;
    function resumeAudioOnInteraction() {
      if (!audioContextResumed && SoundManager.audioContext) {
        audioContextResumed = true;
        SoundManager.hasUserInteracted = true;
        SoundManager.ensureResumed().catch(() => {});
      }
    }
    
    document.addEventListener('touchstart', resumeAudioOnInteraction, { once: true, passive: true, capture: true });
    document.addEventListener('click', resumeAudioOnInteraction, { once: true, capture: true });
    document.addEventListener('keydown', resumeAudioOnInteraction, { once: true, capture: true });

    // Draw cyber bird
    function drawBird() {
      ctx.save();
      
      // Apply glitch effect if active
      if (bird.glitching) {
        const glitchOffsetX = (Math.random() - 0.5) * 4;
        const glitchOffsetY = (Math.random() - 0.5) * 4;
        ctx.translate(bird.x + glitchOffsetX, bird.y + glitchOffsetY);
        ctx.rotate(bird.rotation + (Math.random() - 0.5) * 0.2);
        ctx.filter = `hue-rotate(${Math.random() * 360}deg) brightness(${0.8 + Math.random() * 0.4})`;
      } else {
        ctx.translate(bird.x, bird.y);
        ctx.rotate(bird.rotation);
      }
      
      // Apply ghost effect (transparency) if ghosting
      if (bird.ghosting) {
        // Flicker effect for ghost mode - alternate between visible and transparent
        const timeLeft = bird.ghostEndTime - performance.now();
        const flickerRate = 200; // milliseconds per flicker
        const flickerPhase = Math.floor(timeLeft / flickerRate) % 2;
        ctx.globalAlpha = flickerPhase === 0 ? 0.3 : 0.6; // Flicker between 30% and 60% opacity
      } else {
        ctx.globalAlpha = 1.0;
      }

      // Handle blinking animation
      const currentTime = performance.now();
      const BLINK_DURATION = 150; // milliseconds for a blink
      const MIN_BLINK_INTERVAL = 1000; // Minimum time between blinks (2 seconds)
      const MAX_BLINK_INTERVAL = 2000; // Maximum time between blinks (5 seconds)
      
      // Initialize next blink time if not set
      if (bird.nextBlinkTime === 0) {
        bird.nextBlinkTime = currentTime + MIN_BLINK_INTERVAL + Math.random() * (MAX_BLINK_INTERVAL - MIN_BLINK_INTERVAL);
      }
      
      // Check if it's time to start a blink
      if (!bird.blinking && currentTime >= bird.nextBlinkTime) {
        bird.blinking = true;
        bird.blinkStartTime = currentTime;
      }
      
      // Check if blink should end
      if (bird.blinking && currentTime - bird.blinkStartTime >= BLINK_DURATION) {
        bird.blinking = false;
        // Schedule next random blink
        bird.nextBlinkTime = currentTime + MIN_BLINK_INTERVAL + Math.random() * (MAX_BLINK_INTERVAL - MIN_BLINK_INTERVAL);
      }

      // Wing animation (continuously flapping when playing)
      // Note: Wing animation is frame-based for smooth visual effect
      if (gameState === 'playing' || gameState === 'paused') {
        bird.wingAngle += 0.3;
      }
      // Wing flapping: angle oscillates upward (negative angle, so it goes up and can block eye)
      const wingFlapAngle = -Math.sin(bird.wingAngle) * 0.3; // -0.6 to 0.6 radians (~-35 to 35 degrees), negative so it flaps upward

      // Body glow
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 20;
      
      // Body (main circle) - cache gradient
      if (!cachedBirdGradient) {
        cachedBirdGradient = ctx.createRadialGradient(0, -5, 0, 0, 0, BIRD_SIZE);
        cachedBirdGradient.addColorStop(0, '#00f5ff');
        cachedBirdGradient.addColorStop(0.5, '#0099cc');
        cachedBirdGradient.addColorStop(1, '#006699');
      }
      ctx.fillStyle = cachedBirdGradient;
      ctx.beginPath();
      ctx.arc(0, 0, BIRD_SIZE * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // Tail
      ctx.fillStyle = '#00aacc';
      ctx.beginPath();
      ctx.moveTo(-BIRD_SIZE * 0.2, 0);
      ctx.lineTo(-BIRD_SIZE * 1.2, -5);
      ctx.lineTo(-BIRD_SIZE * 1.4, 5);
      ctx.closePath();
      ctx.fill();

      // Cyber lines/details (drawn first so they appear under wing and eye)
      ctx.strokeStyle = '#00f5ff';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 5;
      ctx.shadowColor = '#00f5ff';
      


      // Beak (small triangle pointing forward/right)
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#cc562a';
      ctx.strokeStyle = '#cc562a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(BIRD_SIZE * 0.6, -2); // Start at right edge of body
      ctx.lineTo(BIRD_SIZE * 0.6 + 6, -0.5); // Point forward
      ctx.lineTo(BIRD_SIZE * 0.6, 2); // Back to body
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Eye (on the right side, facing forward) - always drawn last so it's always on top
      ctx.shadowBlur = 0;
      if (bird.blinking) {
        // Draw closed eye (horizontal line) when blinking
        ctx.strokeStyle = '#00f5ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(8 - 5, -5);
        ctx.lineTo(8 + 5, -5);
        ctx.stroke();
      } else {
        // Draw open eye (circle)
        ctx.fillStyle = '#00f5ff';
        ctx.beginPath();
        ctx.arc(8, -5, 6, 0, Math.PI * 2);
        ctx.fill();
        
        // Eye glow
        ctx.shadowColor = '#ffeb3b';
        ctx.shadowBlur = 10;
        ctx.fillStyle = '#00aacc';
        ctx.beginPath();
        ctx.arc(8, -5, 4, 0, Math.PI * 2);
        ctx.fill();
      }

      // Wing (on the right side, base fixed, tip moves upward)
      // Drawn after lines so it appears on top of them
      ctx.shadowBlur = 20;
      ctx.shadowColor = '#00f5ff';
      ctx.save();
      // Position at base point (fixed on right side, moved left and down a bit), then rotate around that point
      ctx.translate(-5, 2);
      ctx.rotate(wingFlapAngle - 0.2); // Add anti-clockwise rotation offset (about 11 degrees)
      // Draw wing with base at origin, extending to the left (negative x since it's on right side)
      // Make it slightly bigger and add dark blue outline
      ctx.fillStyle = '#00f5ff';
      ctx.strokeStyle = '#00aacc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.ellipse(-6, 0, 15, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Fluffy feather texture on the wing - optimized batch drawing
      ctx.save();
      ctx.strokeStyle = '#00d9ff';
      ctx.lineWidth = 1.5;
      ctx.shadowBlur = 2;
      ctx.shadowColor = '#00d9ff';
      
      // Draw feather-like curves aligned with wing direction (less radial, more directional)
      const wingCenterX = -1;
      const wingCenterY = 0;
      const wingWidth = 30;
      const wingHeight = 4;
      
      // Batch draw all feathers in one path for better performance
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      
      // Outer row of feathers (near the edge)
      const outerRowCount = 6;
      for (let i = 0; i < outerRowCount; i++) {
        const t = i / (outerRowCount - 1);
        const yOffset = (t - 0.5) * wingHeight;
        const startX = wingCenterX - wingWidth * 0.2;
        const startY = wingCenterY + yOffset;
        const endX = wingCenterX - wingWidth * 0.2;
        const endY = wingCenterY + yOffset * 1.1;
        ctx.moveTo(startX, startY);
        const curveOffset = (t - 0.5);
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2 + curveOffset;
        ctx.quadraticCurveTo(midX, midY, endX, endY);
      }
      ctx.stroke();
      
      // Middle row of feathers
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      const middleRowCount = 5;
      for (let i = 0; i < middleRowCount; i++) {
        const t = i / (middleRowCount - 1);
        const yOffset = (t - 0.5) * wingHeight * 1.2;
        const startX = wingCenterX - wingWidth * 0.15;
        const startY = wingCenterY + yOffset;
        const endX = wingCenterX - wingWidth * 0.65;
        const endY = wingCenterY + yOffset * 1.05;
        ctx.moveTo(startX, startY);
        const curveOffset = (t - 0.5) * 1.5;
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2 + curveOffset;
        ctx.quadraticCurveTo(midX, midY, endX, endY);
      }
      ctx.stroke();
      
      // Inner row of smaller feathers
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      const innerRowCount = 4;
      for (let i = 0; i < innerRowCount; i++) {
        const t = i / (innerRowCount - 1);
        const yOffset = (t - 0.5) * wingHeight * 1.0;
        const startX = wingCenterX - wingWidth * 0.05;
        const startY = wingCenterY + yOffset;
        const endX = wingCenterX - wingWidth * 0.45;
        const endY = wingCenterY + yOffset * 1.02;
        ctx.moveTo(startX, startY);
        const curveOffset = (t - 0.5) * 1;
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2 + curveOffset;
        ctx.quadraticCurveTo(midX, midY, endX, endY);
      }
      ctx.stroke();
      
      ctx.restore(); // Restore feather texture settings
      ctx.restore(); // Restore wing transform

      ctx.restore();
      // Reset filter and alpha after drawing
      if (bird.glitching) {
        ctx.filter = 'none';
      }
      ctx.globalAlpha = 1.0;
    }

    // Draw pipe
    function drawPipe(x, y, height, isTop, passed = false) {
      const capHeight = 25;
      
      // Cache pipe gradient (reuse for all pipes)
      if (!cachedPipeGradient) {
        cachedPipeGradient = ctx.createLinearGradient(0, 0, PIPE_WIDTH, 0);
        cachedPipeGradient.addColorStop(0, '#00f5ff');
        cachedPipeGradient.addColorStop(0.5, '#0099cc');
        cachedPipeGradient.addColorStop(1, '#006699');
      }
      const gradient = cachedPipeGradient;
      
      // Calculate body area (excluding cap) - draw body only in this area
      let bodyY = y;
      let bodyHeight = height;
      if (isTop) {
        // Top pipe: cap is at bottom, so body is from y to y + height - capHeight
        bodyHeight = height - capHeight;
      } else {
        // Bottom pipe: cap is at top, so body starts after cap
        bodyY = y + capHeight;
        bodyHeight = height - capHeight;
      }
      
      ctx.fillStyle = gradient;
      ctx.shadowColor = '#00f5ff';
      ctx.shadowBlur = 15;
      
      // Main pipe body (only draw in body area, not where cap will be)
      ctx.fillRect(x, bodyY, PIPE_WIDTH, bodyHeight);
      
      // Cyber grid pattern (only on pipe body, not on cap area) - optimized batch drawing
      ctx.strokeStyle = '#00f5ff';
      ctx.lineWidth = 1;
      ctx.shadowBlur = 5;
      
      // Batch horizontal lines
      ctx.beginPath();
      for (let i = 0; i < bodyHeight; i += 15) {
        ctx.moveTo(x, bodyY + i);
        ctx.lineTo(x + PIPE_WIDTH, bodyY + i);
      }
      ctx.stroke();
      
      // Batch vertical lines
      ctx.beginPath();
      for (let i = 0; i < PIPE_WIDTH; i += 15) {
        ctx.moveTo(x + i, bodyY);
        ctx.lineTo(x + i, bodyY + bodyHeight);
      }
      ctx.stroke();
      
      // Left side highlight line on pipe body (3D effect)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; // 50% opacity white
      ctx.lineWidth = 10;
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#66ffff';
      ctx.beginPath();
      ctx.moveTo(x + 12, bodyY);
      ctx.lineTo(x + 12, bodyY + bodyHeight);
      ctx.stroke();
      
      ctx.shadowBlur = 0;
      
      // Pipe cap - drawn last so it's on top (green if passed, red if not)
      // Set cap shadow color based on passed status
      const capShadowColor = passed ? '#00ff88' : '#ff6b35';
      
      // Cache cap gradients
      let capGradient;
      if (passed) {
        if (!cachedPipeCapGradientPassed) {
          cachedPipeCapGradientPassed = ctx.createLinearGradient(0, 0, PIPE_WIDTH, 0);
          cachedPipeCapGradientPassed.addColorStop(0, '#00ff88');
          cachedPipeCapGradientPassed.addColorStop(0.5, '#00cc66');
          cachedPipeCapGradientPassed.addColorStop(1, '#009944');
        }
        capGradient = cachedPipeCapGradientPassed;
      } else {
        if (!cachedPipeCapGradientUnpassed) {
          cachedPipeCapGradientUnpassed = ctx.createLinearGradient(0, 0, PIPE_WIDTH, 0);
          cachedPipeCapGradientUnpassed.addColorStop(0, '#ff6b35');
          cachedPipeCapGradientUnpassed.addColorStop(0.5, '#ff0040');
          cachedPipeCapGradientUnpassed.addColorStop(1, '#cc0033');
        }
        capGradient = cachedPipeCapGradientUnpassed;
      }
      
      // Calculate cap position
      let capX, capY;
      if (isTop) {
        capY = y + height - capHeight;
        capX = x - 4;
      } else {
        capY = y;
        capX = x - 4;
      }
      
      // Draw cap with shadow for depth
      ctx.fillStyle = capGradient;
      ctx.shadowColor = capShadowColor;
      ctx.shadowBlur = 10;
      ctx.fillRect(capX, capY - 1, PIPE_WIDTH + 10, capHeight + 2);
      
      // Add 3D depth effects
      if (passed) {
        // Top edge highlight (brighter, for 3D top surface)
        ctx.strokeStyle = '#aaffdd'; // Very light green
        ctx.shadowColor = '#aaffdd';
        ctx.shadowBlur = 4;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(capX + 2, capY);
        ctx.lineTo(capX + PIPE_WIDTH + 8, capY);
        ctx.stroke();
        
        // Bottom edge shadow (darker, for depth)
        ctx.strokeStyle = '#006644'; // Dark green
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(capX + 2, capY + capHeight);
        ctx.lineTo(capX + PIPE_WIDTH + 8, capY + capHeight);
        ctx.stroke();
        
        // Left side highlight (vertical, for 3D edge)
        ctx.strokeStyle = '#88ffcc'; // Lighter green
        ctx.shadowColor = '#88ffcc';
        ctx.shadowBlur = 6;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(capX + 7, capY);
        ctx.lineTo(capX + 7, capY + capHeight);
        ctx.stroke();
        
        // Right side shadow (vertical, for depth)
        ctx.strokeStyle = '#006644'; // Dark green
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(capX + PIPE_WIDTH + 3, capY);
        ctx.lineTo(capX + PIPE_WIDTH + 3, capY + capHeight);
        ctx.stroke();
      } else {
        // Top edge highlight (brighter, for 3D top surface)
        ctx.strokeStyle = '#ffcc99'; // Very light orange/red
        ctx.shadowColor = '#ffcc99';
        ctx.shadowBlur = 4;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(capX + 2, capY);
        ctx.lineTo(capX + PIPE_WIDTH + 8, capY);
        ctx.stroke();
        
        // Bottom edge shadow (darker, for depth)
        ctx.strokeStyle = '#660022'; // Dark red
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(capX + 2, capY + capHeight);
        ctx.lineTo(capX + PIPE_WIDTH + 8, capY + capHeight);
        ctx.stroke();
        
        // Left side highlight (vertical, for 3D edge)
        ctx.strokeStyle = '#ffaa66'; // Lighter red/orange
        ctx.shadowColor = '#ffaa66';
        ctx.shadowBlur = 6;
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(capX + 7, capY);
        ctx.lineTo(capX + 7, capY + capHeight);
        ctx.stroke();
        
        // Right side shadow (vertical, for depth)
        ctx.strokeStyle = '#660022'; // Dark red
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(capX + PIPE_WIDTH + 3, capY);
        ctx.lineTo(capX + PIPE_WIDTH + 3, capY + capHeight);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
      ctx.shadowColor = '#00f5ff'; // Reset to default blue for other elements
    }

    // Draw background
    function drawBackground() {
      // Sky gradient (cached for performance)
      if (!cachedSkyGradient || cachedSkyGradient.height !== canvas.height) {
        cachedSkyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        cachedSkyGradient.addColorStop(0, 'rgba(10, 5, 25, 0.8)');
        cachedSkyGradient.addColorStop(1, 'rgba(0, 0, 0, 0.9)');
      }
      ctx.fillStyle = cachedSkyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Parallax stars - use backgroundOffset for smooth parallax effect (more subtle)
      ctx.fillStyle = 'rgba(0, 245, 255, 0.4)'; // Reduced opacity for stars
      ctx.shadowColor = 'rgba(0, 245, 255, 0.3)';
      ctx.shadowBlur = 3; // Reduced glow
      const wrapWidth = canvas.width + 200; // Match the wrap width used for backgroundOffset
      
      // Initialize star positions if not already done
      if (starPositions.length === 0) {
        initializeStarPositions();
      }
      
      // Pre-calculate offset once
      const offsetMod = backgroundOffset % wrapWidth;
      const offsetModNeg = offsetMod < 0 ? offsetMod + wrapWidth : offsetMod;
      
      // Batch star drawing for better performance
      ctx.beginPath();
      for (let i = 0; i < starPositions.length; i++) {
        const star = starPositions[i];
        // Calculate current position with offset, ensuring smooth wrapping
        let x = star.baseX - offsetModNeg;
        // Handle wrapping for negative values - use proper modulo to maintain continuity
        if (x < 0) {
          x = x + wrapWidth;
        } else if (x >= wrapWidth) {
          x = x - wrapWidth;
        }
        // Only draw if visible on canvas (with some margin for smooth scrolling)
        if (x >= -50 && x <= canvas.width + 50) {
          // Simplified size calculation (cache sin values or use simpler formula)
          const size = 2 + (i % 3); // Simpler: 2, 3, or 4 based on index
          ctx.moveTo(x + size, star.y);
          ctx.arc(x, star.y, size, 0, Math.PI * 2);
        }
      }
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Draw cityscape (between stars and pipes for parallax effect)
      drawCityscape();
    }
    
    // Draw cityscape
    function drawCityscape() {
      const groundY = canvas.height - GROUND_HEIGHT;
      const wrapWidth = canvas.width * 2;
      
      // Initialize cityscape if not done
      if (cityscapeBuildings.length === 0) {
        initializeCityscape();
      }
      
      // Calculate cityscape offset with parallax
      let cityX = cityscapeOffset % wrapWidth;
      if (cityX < 0) {
        cityX += wrapWidth;
      }
      
      ctx.save();
      
      // Reset all context properties to ensure static rendering
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      
      // Draw buildings
      for (let i = 0; i < cityscapeBuildings.length; i++) {
        const building = cityscapeBuildings[i];
        let x = building.x - cityX;
        
        // Handle wrapping
        if (x < -building.width) {
          x += wrapWidth;
        } else if (x > canvas.width) {
          x -= wrapWidth;
        }
        
        // Only draw if visible
        if (x >= -building.width && x <= canvas.width) {
          // Main building body (slightly lighter silhouette)
          // Use cached gradient or create once per building width
          if (!cachedBuildingGradient || cachedBuildingGradient.width !== building.width) {
            cachedBuildingGradient = ctx.createLinearGradient(0, building.y, building.width, building.y);
            cachedBuildingGradient.addColorStop(0, 'rgba(10, 15, 25, 1.0)');
            cachedBuildingGradient.addColorStop(0.5, 'rgba(5, 10, 20, 1.0)');
            cachedBuildingGradient.addColorStop(1, 'rgba(10, 15, 25, 1.0)');
          }
          ctx.fillStyle = cachedBuildingGradient;
          ctx.fillRect(x, building.y, building.width, building.height);
          
          // Subtle building edges (very dark, minimal glow)
          ctx.strokeStyle = 'rgba(0, 20, 40, 0.4)';
          ctx.lineWidth = 1;
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          ctx.strokeRect(x, building.y, building.width, building.height);
          
          // Draw windows (subtle, not too bright) - static lighting
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          for (let window of building.windows) {
            let windowX = x + (window.x - building.x);
            if (windowX >= x && windowX <= x + building.width) {
              if (window.neon && window.neonColor) {
                // Neon window - more subtle glow
                const neonColor = window.neonColor;
                // Convert hex to rgba
                const r = parseInt(neonColor.substr(1, 2), 16);
                const g = parseInt(neonColor.substr(3, 2), 16);
                const b = parseInt(neonColor.substr(5, 2), 16);
                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.5)`;
                ctx.shadowColor = neonColor;
                ctx.shadowBlur = 4; // Reduced glow
                ctx.fillRect(windowX, window.y, 8, 12);
              } else if (window.lit) {
                // Lit window (subtle glow - not too bright) - static
                ctx.fillStyle = 'rgba(0, 245, 255, 0.2)';
                ctx.shadowColor = 'rgba(0, 245, 255, 0.3)';
                ctx.shadowBlur = 1;
                ctx.fillRect(windowX, window.y, 8, 12);
              } else {
                // Unlit window (very dark) - static
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 0;
                ctx.shadowColor = 'transparent';
                ctx.fillRect(windowX, window.y, 8, 12);
              }
              // Reset shadow after each window
              ctx.shadowBlur = 0;
              ctx.shadowColor = 'transparent';
            }
          }
          
          // Draw neon signs - vibrant neon colors with strong glow
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          for (let sign of building.neonSigns) {
            let signX = x + (sign.x - building.x);
            if (signX >= x && signX <= x + building.width) {
              // Convert hex color to rgba for vibrant neon glow
              const hex = sign.color;
              const r = parseInt(hex.substr(1, 2), 16);
              const g = parseInt(hex.substr(3, 2), 16);
              const b = parseInt(hex.substr(5, 2), 16);
              
              // Sign glow - more subtle neon glow
              ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.4)`;
              ctx.shadowColor = sign.color;
              ctx.shadowBlur = 6; // Reduced glow
              ctx.fillRect(signX, sign.y, sign.width, sign.height);
              
              // Sign text/pattern (more subtle lines) - static
              ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
              ctx.lineWidth = 1.5;
              ctx.shadowBlur = 3; // Reduced glow
              ctx.shadowColor = sign.color;
              ctx.beginPath();
              ctx.moveTo(signX + 2, sign.y + sign.height / 2);
              ctx.lineTo(signX + sign.width - 2, sign.y + sign.height / 2);
              ctx.stroke();
              
              // Reset shadow after each sign
              ctx.shadowBlur = 0;
              ctx.shadowColor = 'transparent';
            }
          }
          
          // Building top accent (more subtle) - static
          if (building.hasNeonTop) {
            ctx.fillStyle = 'rgba(0, 245, 255, 0.2)';
            ctx.shadowColor = 'rgba(0, 245, 255, 0.3)';
            ctx.shadowBlur = 2;
            ctx.fillRect(x, building.y, building.width, 2);
          }
          
          // Reset shadow after each building to prevent bleed
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
        }
      }
      
      // Draw street lights
      for (let i = 0; i < cityscapeStreetLights.length; i++) {
        const light = cityscapeStreetLights[i];
        let x = light.x - cityX;
        
        // Handle wrapping
        if (x < -10) {
          x += wrapWidth;
        } else if (x > canvas.width) {
          x -= wrapWidth;
        }
        
        // Only draw if visible
        if (x >= -10 && x <= canvas.width) {
          const lightTopY = light.y + light.height;
          
          // Light pole (vertical, more visible)
          ctx.strokeStyle = 'rgba(30, 40, 50, 0.9)';
          ctx.lineWidth = 3;
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          ctx.beginPath();
          ctx.moveTo(x, groundY);
          ctx.lineTo(x, lightTopY - 10);
          ctx.stroke();
          
          // Horizontal arm extending from pole
          ctx.strokeStyle = 'rgba(30, 40, 50, 0.9)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, lightTopY - 10);
          ctx.lineTo(x + 8, lightTopY - 10);
          ctx.stroke();
          
          // Light glow (neon)
          const hex = light.color;
          const r = parseInt(hex.substr(1, 2), 16);
          const g = parseInt(hex.substr(3, 2), 16);
          const b = parseInt(hex.substr(5, 2), 16);
          
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
          ctx.shadowColor = light.color;
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(x + 8, lightTopY - 10, 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Light top (brighter center)
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 1.0)`;
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(x + 8, lightTopY - 10, 2.5, 0, Math.PI * 2);
          ctx.fill();
          
          // Reset shadow
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
        }
      }
      
      // Draw billboards
      for (let i = 0; i < cityscapeBillboards.length; i++) {
        const billboard = cityscapeBillboards[i];
        let x = billboard.x - cityX;
        
        // Handle wrapping
        if (x < -billboard.width) {
          x += wrapWidth;
        } else if (x > canvas.width) {
          x -= wrapWidth;
        }
        
        // Only draw if visible
        if (x >= -billboard.width && x <= canvas.width) {
          // Billboard support posts (dark)
          ctx.strokeStyle = 'rgba(20, 30, 40, 0.8)';
          ctx.lineWidth = 2;
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
          ctx.beginPath();
          ctx.moveTo(x + 5, groundY);
          ctx.lineTo(x + 5, billboard.y + billboard.height);
          ctx.moveTo(x + billboard.width - 5, groundY);
          ctx.lineTo(x + billboard.width - 5, billboard.y + billboard.height);
          ctx.stroke();
          
          // Billboard background (dark)
          ctx.fillStyle = 'rgba(5, 10, 20, 0.9)';
          ctx.fillRect(x, billboard.y, billboard.width, billboard.height);
          
          // Billboard border (neon)
          const hex = billboard.color;
          const r = parseInt(hex.substr(1, 2), 16);
          const g = parseInt(hex.substr(3, 2), 16);
          const b = parseInt(hex.substr(5, 2), 16);
          
          ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
          ctx.lineWidth = 2;
          ctx.shadowColor = billboard.color;
          ctx.shadowBlur = 4;
          ctx.strokeRect(x, billboard.y, billboard.width, billboard.height);
          
          // Billboard text (neon glow effect)
          if (billboard.text) {
            // Add padding around text
            const padding = 6;
            const textAreaWidth = billboard.width - (padding * 2);
            const textAreaHeight = billboard.height - (padding * 2);
            
            // Calculate font size based on available text area and text length
            const baseFontSize = Math.min(textAreaHeight * 0.6, textAreaWidth / (billboard.text.length * 0.6));
            
            // Use the assigned font for this billboard, or default to Arial bold
            const fontInfo = billboard.font || { family: 'Arial', weight: 'bold', style: 'normal' };
            const styleStr = fontInfo.style !== 'normal' ? fontInfo.style + ' ' : '';
            ctx.font = `${styleStr}${fontInfo.weight} ${Math.floor(baseFontSize)}px ${fontInfo.family}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.9)`;
            ctx.shadowColor = billboard.color;
            ctx.shadowBlur = 6;
            // Draw text centered on billboard with padding
            ctx.fillText(
              billboard.text,
              x + billboard.width / 2,
              billboard.y + billboard.height / 2
            );
          } else {
            // Fallback to lines if no text (shouldn't happen, but just in case)
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 3;
            ctx.beginPath();
            ctx.moveTo(x + 5, billboard.y + billboard.height * 0.3);
            ctx.lineTo(x + billboard.width - 5, billboard.y + billboard.height * 0.3);
            ctx.moveTo(x + 5, billboard.y + billboard.height * 0.5);
            ctx.lineTo(x + billboard.width - 5, billboard.y + billboard.height * 0.5);
            ctx.moveTo(x + 5, billboard.y + billboard.height * 0.7);
            ctx.lineTo(x + billboard.width - 5, billboard.y + billboard.height * 0.7);
            ctx.stroke();
          }
          
          // Reset shadow
          ctx.shadowBlur = 0;
          ctx.shadowColor = 'transparent';
        }
      }
      
      ctx.restore();
    }

    // Draw ground
    function drawGround() {
      const groundY = canvas.height - GROUND_HEIGHT;
      
      // Ground fill background (solid base color - visible behind everything)
      ctx.fillStyle = '#006699';
      ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);
      
      // Ground base gradient (semi-transparent overlay to show base through)
      const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);
      groundGradient.addColorStop(0, 'rgba(0, 51, 68, 0.6)'); // More transparent
      groundGradient.addColorStop(0.5, 'rgba(0, 17, 34, 0.4)');
      groundGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, groundY, canvas.width, GROUND_HEIGHT);
      
      // Create pattern cache if not already created
      if (!groundPatternCached || !groundPatternCanvas) {
        createGroundPattern();
      }
      
      // Draw cached pattern with scrolling offset (much faster than drawing each frame)
      const patternSpacing = 20;
      const patternOffset = groundOffset % (patternSpacing * 10); // Wrap to pattern width
      
      // Save context to clip to ground area
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, groundY, canvas.width, GROUND_HEIGHT);
      ctx.clip();
      
      // Draw the cached pattern, tiling it horizontally
      const patternWidth = patternSpacing * 10;
      let drawX = -patternOffset;
      
      // Draw enough copies to cover the screen
      while (drawX < canvas.width) {
        ctx.drawImage(groundPatternCanvas, drawX, groundY);
        drawX += patternWidth;
      }
      
      // Restore context (remove clipping)
      ctx.restore();
      
      // Top edge glow
      ctx.strokeStyle = '#00f5ff';
      ctx.lineWidth = 2;
      ctx.shadowBlur = 10;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.moveTo(0, groundY);
      ctx.lineTo(canvas.width, groundY);
      ctx.stroke();
      
      // Reset alpha
      ctx.globalAlpha = 1.0;
      ctx.shadowBlur = 0;
    }

    // Game loop
    function gameLoop(currentTime) {
      // Initialize time if not provided (first call)
      if (!currentTime) {
        currentTime = performance.now();
      }
      
      // Calculate delta time for frame-rate independent movement
      const deltaTime = Math.min((currentTime - lastTime) / 16.67, 2.0); // Cap at 2x normal speed
      lastTime = currentTime;
      
      // Update window lighting dynamically (every few seconds)
      if (currentTime - lastWindowUpdate >= WINDOW_UPDATE_INTERVAL) {
        lastWindowUpdate = currentTime;
        // Randomly toggle 1-2 windows per building
        for (let building of cityscapeBuildings) {
          // Get all non-neon windows for this building
          const nonNeonWindows = building.windows.filter(w => !w.neon);
          if (nonNeonWindows.length > 0) {
            // Toggle 1-2 random windows
            const numToToggle = Math.random() > 0.5 ? 1 : 2;
            const shuffled = [...nonNeonWindows].sort(() => Math.random() - 0.5);
            for (let i = 0; i < Math.min(numToToggle, shuffled.length); i++) {
              shuffled[i].lit = !shuffled[i].lit;
            }
          }
        }
      }
      
      // Only increment frameCount when playing (so background doesn't move when paused)
      if (gameState === 'playing') {
        frameCount += deltaTime;
        // Update parallax background offset based on pipe speed
        // Background moves slower than pipes for parallax effect
        backgroundOffset += pipeSpeed * deltaTime * PARALLAX_FACTOR;
        // Don't wrap the offset - let it grow indefinitely and use modulo in star calculation
        // This prevents discontinuities when wrapping
        const maxOffset = (canvas.width + 200) * 1000; // Very large number to prevent overflow
        if (backgroundOffset > maxOffset) {
          backgroundOffset = backgroundOffset % maxOffset;
        }
        // Update cityscape offset (between stars and pipes)
        cityscapeOffset += pipeSpeed * deltaTime * CITYSCAPE_PARALLAX_FACTOR;
        const cityscapeWrapWidth = canvas.width * 2;
        if (cityscapeOffset > cityscapeWrapWidth * 1000) {
          cityscapeOffset = cityscapeOffset % (cityscapeWrapWidth * 1000);
        }
        // Update ground offset - moves at same speed as pipes for consistent movement
        groundOffset += pipeSpeed * deltaTime;
        // Wrap around to prevent overflow
        if (groundOffset > 2000) {
          groundOffset = groundOffset % 2000;
        }
        
        // Spawn planes occasionally
        if (currentTime - lastPlaneSpawn >= PLANE_SPAWN_INTERVAL) {
          lastPlaneSpawn = currentTime;
          // Random chance to spawn (60% chance)
          if (Math.random() > 0.4) {
            const groundY = canvas.height - GROUND_HEIGHT;
            const planeY = 50 + Math.random() * (groundY - 150); // Random height, avoid ground and top
            const neonColors = ['#00f5ff', '#ff00ff', '#ffff00', '#00ff88'];
            planes.push({
              x: canvas.width + 30, // Start off-screen right
              y: planeY,
              color: neonColors[Math.floor(Math.random() * neonColors.length)],
              size: 15 + Math.random() * 10 // 15-25px size
            });
          }
        }
        
        // Update planes (move left)
        for (let i = planes.length - 1; i >= 0; i--) {
          planes[i].x -= PLANE_SPEED * deltaTime;
          // Remove planes that are off-screen
          if (planes[i].x + planes[i].size < 0) {
            planes.splice(i, 1);
          }
        }
      }
      animationFrame = requestAnimationFrame(gameLoop);

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw background
      drawBackground();
      
      // Draw planes (behind pipes but in front of buildings)
      drawPlanes();
      
      // Draw ground
      drawGround();

      if (gameState === 'playing' || gameState === 'falling') {
        // Check if ghost mode should end
        if (bird.ghosting && performance.now() >= bird.ghostEndTime) {
          bird.ghosting = false;
        }
        
        // Update bird (time-based)
        if (gameState === 'playing') {
          // Apply jump at intervals if space/mouse is held
          if (spaceHeld || mouseHeld) {
            const timeSinceLastJump = currentTime - lastJumpTime;
            if (timeSinceLastJump >= JUMP_INTERVAL) {
              // Apply jump force at interval
              bird.velocity = JUMP_STRENGTH;
              lastJumpTime = currentTime;
              SoundManager.playFlap();
              // Trigger wing flapping animation
              bird.wingFlapping = true;
              bird.wingFlapDecay = 1.0;
            } else {
              // Apply gravity between jumps
              bird.velocity += GRAVITY * deltaTime;
            }
          } else {
            // Apply gravity when not held
            bird.velocity += GRAVITY * deltaTime;
          }
        } else if (gameState === 'falling') {
          // When falling, only apply gravity (no controls)
          bird.velocity += GRAVITY * deltaTime;
        }
        bird.y += bird.velocity * deltaTime;
        
        // Rotation based on velocity
        bird.rotation = Math.min(Math.max(bird.velocity * 0.1, -0.5), 0.5);

        // Update pipes (only if enabled, time-based, and not falling)
        if (pipesEnabled && gameState === 'playing') {
          for (let i = pipes.length - 1; i >= 0; i--) {
            pipes[i].x -= pipeSpeed * deltaTime;

            // Check if bird passed pipe
            if (!pipes[i].scored && pipes[i].x + PIPE_WIDTH < bird.x) {
              pipes[i].scored = true;
              score++;
              updateScores();
              SoundManager.playScore();
            }

            // Remove off-screen pipes
            if (pipes[i].x + PIPE_WIDTH < 0) {
              pipes.splice(i, 1);
            }
          }
        }

        // Add new pipes - spawn when no pipes exist or when last pipe is far enough from right edge (only when playing, not falling)
        if (pipesEnabled && gameState === 'playing') {
          let shouldSpawn = false;
          if (pipes.length === 0) {
            shouldSpawn = true;
          } else {
            const lastPipe = pipes[pipes.length - 1];
            if (lastPipe.x <= canvas.width - pipeSpacing) {
              shouldSpawn = true;
            }
          }
          
          if (shouldSpawn) {
            const groundY = canvas.height - GROUND_HEIGHT;
            const gapY = Math.random() * (groundY - pipeGap - 100) + 50;
            pipes.push({
              x: canvas.width,
              topHeight: gapY,
              bottomY: gapY + pipeGap,
              scored: false,
              hit: false
            });
          }
        } else if (!pipesEnabled) {
          // Clear pipes if disabled
          pipes = [];
        }

        // Collision detection with pipes (check BEFORE drawing so pipes can be transparent immediately)
        let hasCollision = false;
        if (gameState === 'playing' && !bird.ghosting && pipesEnabled) {
          const collidedPipe = checkCollision(bird, pipes);
          if (collidedPipe) {
            // Mark pipe as hit to prevent multiple collision detections
            collidedPipe.hit = true;
            hasCollision = true;
            
            // Check if this is the last life - if so, start falling; otherwise use ghost mode
            if (currentLives <= 1) {
              // Last life - decrement to 0, start falling
              currentLives = 0;
              updateLivesDisplay();
              gameState = 'falling';
              SoundManager.playCrash();
              // Disable controls
              spaceHeld = false;
              mouseHeld = false;
            } else {
              // Not last life - use ghost mode system
              gameOver();
            }
          }
        }

        // Boundary constraints - keep bird within play area
        const birdRadius = BIRD_SIZE * 0.6;
        if (bird.y - birdRadius < 0) {
          bird.y = birdRadius;
          bird.velocity = 0; // Stop upward movement at top
        }
        
        // Ground collision - check if bird hits ground
        const groundY = canvas.height - GROUND_HEIGHT;
        if (bird.y + birdRadius > groundY) {
          bird.y = groundY - birdRadius;
          bird.velocity = 0; // Stop downward movement at ground
          
          // If falling, show game over screen when hitting ground
          if (gameState === 'falling') {
            gameState = 'gameover';
            finalScoreEl.textContent = score;
            gameOverEl.classList.add('show');
            updateLivesDisplay(); // Ensure all hearts are greyed out
            updatePauseButton();
          }
        }

        // Draw pipes (only if enabled)
        if (pipesEnabled) {
          const groundY = canvas.height - GROUND_HEIGHT;
          pipes.forEach(pipe => {
            drawPipe(pipe.x, 0, pipe.topHeight, true, pipe.scored);
            drawPipe(pipe.x, pipe.bottomY, groundY - pipe.bottomY, false, pipe.scored);
          });
        }
      } else if (gameState === 'paused') {
        // Draw pipes (static) when paused (only if enabled)
        if (pipesEnabled) {
          const groundY = canvas.height - GROUND_HEIGHT;
          pipes.forEach(pipe => {
            drawPipe(pipe.x, 0, pipe.topHeight, true, pipe.scored);
            drawPipe(pipe.x, pipe.bottomY, groundY - pipe.bottomY, false, pipe.scored);
          });
        }
      } else if (gameState === 'falling' || gameState === 'gameover') {
        // Draw pipes normally when falling or gameover
        if (pipesEnabled) {
          const groundY = canvas.height - GROUND_HEIGHT;
          pipes.forEach(pipe => {
            drawPipe(pipe.x, 0, pipe.topHeight, true, pipe.scored);
            drawPipe(pipe.x, pipe.bottomY, groundY - pipe.bottomY, false, pipe.scored);
          });
        }
      }

      // Draw bird
      drawBird();
    }
    
    // Draw planes
    function drawPlanes() {
      for (let plane of planes) {
        ctx.save();
        
        const hex = plane.color;
        const r = parseInt(hex.substr(1, 2), 16);
        const g = parseInt(hex.substr(3, 2), 16);
        const b = parseInt(hex.substr(5, 2), 16);
        
        // Plane body (main fuselage)
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
        ctx.shadowColor = plane.color;
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.ellipse(plane.x, plane.y, plane.size * 0.6, plane.size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Wings (cyberpunk style - angular)
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.6)`;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        // Top wing
        ctx.moveTo(plane.x - plane.size * 0.3, plane.y - plane.size * 0.2);
        ctx.lineTo(plane.x - plane.size * 0.8, plane.y - plane.size * 0.6);
        ctx.lineTo(plane.x - plane.size * 0.5, plane.y - plane.size * 0.3);
        ctx.closePath();
        ctx.fill();
        // Bottom wing
        ctx.beginPath();
        ctx.moveTo(plane.x - plane.size * 0.3, plane.y + plane.size * 0.2);
        ctx.lineTo(plane.x - plane.size * 0.8, plane.y + plane.size * 0.6);
        ctx.lineTo(plane.x - plane.size * 0.5, plane.y + plane.size * 0.3);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit/light (brighter)
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 1.0)`;
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(plane.x + plane.size * 0.2, plane.y, plane.size * 0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail fin
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.7)`;
        ctx.shadowBlur = 5;
        ctx.beginPath();
        ctx.moveTo(plane.x - plane.size * 0.6, plane.y);
        ctx.lineTo(plane.x - plane.size * 0.9, plane.y - plane.size * 0.4);
        ctx.lineTo(plane.x - plane.size * 0.7, plane.y);
        ctx.closePath();
        ctx.fill();
        
        // Engine glow (trail)
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
        ctx.shadowBlur = 12;
        ctx.shadowColor = plane.color;
        ctx.beginPath();
        ctx.ellipse(plane.x - plane.size * 0.8, plane.y, plane.size * 0.4, plane.size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
    }

    // Collision detection
    function checkCollision(bird, pipes) {
      // Skip collision check if bird is ghosting (invulnerable)
      if (bird.ghosting) {
        return null;
      }
      
      const birdRadius = BIRD_SIZE * 0.6;
      
      for (let pipe of pipes) {
        // Skip pipes that have already been hit
        if (pipe.hit) {
          continue;
        }
        
        // Top pipe
        if (bird.x + birdRadius > pipe.x &&
            bird.x - birdRadius < pipe.x + PIPE_WIDTH &&
            bird.y - birdRadius < pipe.topHeight) {
          return pipe;
        }
        
        // Bottom pipe
        if (bird.x + birdRadius > pipe.x &&
            bird.x - birdRadius < pipe.x + PIPE_WIDTH &&
            bird.y + birdRadius > pipe.bottomY) {
          return pipe;
        }
      }
      
      return null;
    }

    // Update scores
    function updateScores() {
      scoreEl.textContent = score;
      if (score > highscore) {
        highscore = score;
        localStorage.setItem('highscore', highscore.toString());
      }
      highscoreEl.textContent = highscore;
    }

    // Start game
    function startGame() {
      if (gameState === 'paused') {
        gameState = 'playing';
        updatePauseButton();
        SoundManager.playFlap();
      }
    }

    // Pause game
    function pauseGame() {
      if (gameState === 'playing') {
        gameState = 'paused';
        updatePauseButton();
      }
    }

    // Resume game
    function resumeGame() {
      if (gameState === 'paused') {
        gameState = 'playing';
        updatePauseButton();
      }
    }

    // Toggle pause
    function togglePause() {
      if (gameState === 'playing') {
        pauseGame();
      } else if (gameState === 'paused') {
        resumeGame();
      }
    }

    // Update pause button icon
    function updatePauseButton() {
      const icon = pauseBtn.querySelector('.material-icons');
      if (gameState === 'paused') {
        icon.textContent = 'play_arrow';
        pauseBtn.disabled = false;
      } else if (gameState === 'playing') {
        icon.textContent = 'pause';
        pauseBtn.disabled = false;
      } else {
        pauseBtn.disabled = true;
      }
    }

    // Show menu modal
    function showMenu() {
      menuModal.classList.add('show');
      showMainMenu();
    }

    // Hide menu modal
    function hideMenu() {
      menuModal.classList.remove('show');
    }

    // Show main menu screen
    function showMainMenu() {
      mainMenuScreen.classList.add('active');
      howToPlayScreen.classList.remove('active');
      settingsScreen.classList.remove('active');
    }

    // Show how to play screen
    function showHowToPlay() {
      mainMenuScreen.classList.remove('active');
      howToPlayScreen.classList.add('active');
      settingsScreen.classList.remove('active');
    }

    // Show settings screen
    function showSettings() {
      mainMenuScreen.classList.remove('active');
      howToPlayScreen.classList.remove('active');
      settingsScreen.classList.add('active');
    }

    // Toggle pipes setting
    function togglePipes() {
      pipesEnabled = !pipesEnabled;
      pipesToggle.classList.toggle('active', pipesEnabled);
      // Clear existing pipes when disabled
      if (!pipesEnabled) {
        pipes = [];
      }
      // Save to localStorage
      localStorage.setItem('pipesEnabled', pipesEnabled.toString());
    }

    // Update pipe settings
    function updatePipeSettings() {
      pipeSpacing = parseInt(pipeSpacingInput.value) || DEFAULT_PIPE_SPACING;
      pipeGap = parseInt(pipeGapInput.value) || DEFAULT_PIPE_GAP;
      pipeSpeed = parseFloat(pipeSpeedInput.value) || DEFAULT_PIPE_SPEED;
      
      // Save to localStorage
      localStorage.setItem('pipeSpacing', pipeSpacing.toString());
      localStorage.setItem('pipeGap', pipeGap.toString());
      localStorage.setItem('pipeSpeed', pipeSpeed.toString());
    }

    // Update lives setting
    function updateLives() {
      maxLives = parseInt(livesInput.value) || 1;
      if (maxLives < 1) maxLives = 1;
      if (maxLives > 10) maxLives = 10;
      livesInput.value = maxLives;
      // Reset current lives to max when changing setting
      currentLives = maxLives;
      updateLivesDisplay();
      localStorage.setItem('maxLives', maxLives.toString());
    }

    // Update lives display
    function updateLivesDisplay() {
      // Clear existing hearts
      livesDisplay.innerHTML = '';
      // Add heart icons for max lives, grey out lost ones
      for (let i = 0; i < maxLives; i++) {
        const heart = document.createElement('span');
        heart.className = 'material-icons';
        heart.textContent = 'favorite';
        // Grey out hearts that represent lost lives (including when currentLives is 0)
        if (i >= currentLives || currentLives <= 0) {
          heart.classList.add('greyed');
        }
        livesDisplay.appendChild(heart);
      }
    }

    // Update ghost duration setting
    function updateGhostDuration() {
      ghostDuration = parseInt(ghostDurationInput.value) || 3000;
      if (ghostDuration < 500) ghostDuration = 500;
      if (ghostDuration > 5000) ghostDuration = 5000;
      ghostDurationInput.value = ghostDuration;
      localStorage.setItem('ghostDuration', ghostDuration.toString());
    }

    // Reset high score
    function resetHighscore() {
      highscore = 0;
      localStorage.removeItem('highscore');
      highscoreEl.textContent = highscore;
    }

    // Reset all settings to defaults
    function resetAllSettings() {
      pipesEnabled = true;
      pipeSpacing = DEFAULT_PIPE_SPACING;
      pipeGap = DEFAULT_PIPE_GAP;
      pipeSpeed = DEFAULT_PIPE_SPEED;
      maxLives = 1;
      ghostDuration = 3000;
      
      // Update UI
      pipesToggle.classList.add('active');
      pipeSpacingInput.value = DEFAULT_PIPE_SPACING;
      pipeGapInput.value = DEFAULT_PIPE_GAP;
      pipeSpeedInput.value = DEFAULT_PIPE_SPEED;
      livesInput.value = 1;
      ghostDurationInput.value = 3000;
      
      // Reset lives
      currentLives = maxLives;
      updateLivesDisplay();
      
      // Clear pipes when resetting
      pipes = [];
      
      // Save to localStorage
      localStorage.setItem('pipesEnabled', 'true');
      localStorage.setItem('pipeSpacing', DEFAULT_PIPE_SPACING.toString());
      localStorage.setItem('pipeGap', DEFAULT_PIPE_GAP.toString());
      localStorage.setItem('pipeSpeed', DEFAULT_PIPE_SPEED.toString());
      localStorage.setItem('maxLives', '1');
      localStorage.setItem('ghostDuration', '3000');
    }

    // Load settings from localStorage
    function loadSettings() {
      const savedPipes = localStorage.getItem('pipesEnabled');
      if (savedPipes !== null) {
        pipesEnabled = savedPipes === 'true';
        pipesToggle.classList.toggle('active', pipesEnabled);
      }
      
      const savedSpacing = localStorage.getItem('pipeSpacing');
      if (savedSpacing !== null) {
        pipeSpacing = parseInt(savedSpacing);
        pipeSpacingInput.value = pipeSpacing;
      }
      
      const savedGap = localStorage.getItem('pipeGap');
      if (savedGap !== null) {
        pipeGap = parseInt(savedGap);
        pipeGapInput.value = pipeGap;
      }
      
      const savedSpeed = localStorage.getItem('pipeSpeed');
      if (savedSpeed !== null) {
        pipeSpeed = parseFloat(savedSpeed);
        pipeSpeedInput.value = pipeSpeed;
      }
      
      const savedLives = localStorage.getItem('maxLives');
      if (savedLives !== null) {
        maxLives = parseInt(savedLives) || 1;
        livesInput.value = maxLives;
      }
      currentLives = maxLives;
      updateLivesDisplay();
      
      const savedGhostDuration = localStorage.getItem('ghostDuration');
      if (savedGhostDuration !== null) {
        ghostDuration = parseInt(savedGhostDuration) || 3000;
        ghostDurationInput.value = ghostDuration;
      }
    }

    // Game over
    function gameOver() {
      // Only trigger game over when playing (not when already falling or gameover)
      if (gameState !== 'playing') return;
      
      // Decrement lives
      currentLives--;
      updateLivesDisplay();
      
      // If lives remaining, activate ghost mode and continue
      if (currentLives > 0) {
        // Brief pause to show collision
        gameState = 'paused';
        SoundManager.playCrash();
        
        // Activate ghost mode after short delay (bird continues from current position)
        setTimeout(() => {
          // Activate ghost mode
          bird.ghosting = true;
          bird.ghostEndTime = performance.now() + ghostDuration;
          // Resume game (bird continues from where it collided)
          gameState = 'playing';
          updatePauseButton();
        }, 500);
        return;
      }
      
      // No lives left - start falling (will trigger game over when hitting ground)
      gameState = 'falling';
      SoundManager.playCrash();
      // Disable controls
      spaceHeld = false;
      mouseHeld = false;
    }

    // Restart game
    function restartGame() {
      // Cancel any existing animation frame to prevent multiple loops
      if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = 0;
      }
      
      // Reset bird properties immediately to prevent accumulation during delay
      bird.wingAngle = 30; // Reset wing animation
      bird.wingFlapping = false; // Reset wing flapping state
      bird.wingFlapDecay = 0; // Reset wing flap decay
      bird.glitching = false; // Reset glitch state
      bird.ghosting = false; // Reset ghost mode
      bird.blinking = false; // Reset blink state
      bird.nextBlinkTime = 0; // Reset blink timer
      
      // Add glitch animations
      restartBtn.classList.add('glitch');
      canvas.classList.add('glitch');
      bird.glitching = true;
      SoundManager.playReboot();
      
      // Remove glitch animations after they complete
      setTimeout(() => {
        restartBtn.classList.remove('glitch');
        canvas.classList.remove('glitch');
        bird.glitching = false;
      }, 300);
      
      // Small delay before restarting to show animation
      setTimeout(() => {
        gameState = 'paused';
        gameOverEl.classList.remove('show');
        bird.y = canvas.height / 2;
        bird.velocity = 0;
        bird.rotation = 0;
        bird.wingAngle = 30; // Reset wing animation again (in case it changed during delay)
        bird.wingFlapping = false; // Reset wing flapping state
        bird.wingFlapDecay = 0; // Reset wing flap decay
        bird.ghosting = false; // Reset ghost mode
        bird.blinking = false; // Reset blink state
        bird.nextBlinkTime = 0; // Reset blink timer
        pipes = [];
        planes = []; // Reset planes
        score = 0;
        frameCount = 0;
        backgroundOffset = 0; // Reset parallax offset
        cityscapeOffset = 0; // Reset cityscape offset
        groundOffset = 0; // Reset ground offset
        lastWindowUpdate = performance.now(); // Reset window update timer
        lastPlaneSpawn = performance.now(); // Reset plane spawn timer
        currentLives = maxLives; // Reset lives
        updateLivesDisplay();
        lastTime = performance.now(); // Reset time tracking
        updateScores();
        updatePauseButton();
        gameLoop();
      }, 100);
    }

    // Start jump (for initial press)
    function startJump() {
      if (gameState === 'gameover') {
        // Restart game when gameover
        restartGame();
      } else if (gameState === 'paused') {
        resumeGame();
      } else if (gameState === 'playing') {
        // Set initial velocity and mark as held
        bird.velocity = JUMP_STRENGTH;
        lastJumpTime = performance.now();
        SoundManager.playFlap();
        // Trigger wing flapping animation
        bird.wingFlapping = true;
        bird.wingFlapDecay = 1.0;
      }
      // Ignore input when falling
    }

    // Event listeners
    restartBtn.addEventListener('click', restartGame);
    restartGameBtn.addEventListener('click', restartGame);
    pauseBtn.addEventListener('click', togglePause);
    menuBtn.addEventListener('click', showMenu);
    howToPlayBtn.addEventListener('click', showHowToPlay);
    settingsBtn.addEventListener('click', showSettings);
    backFromHowToPlay.addEventListener('click', showMainMenu);
    backFromSettings.addEventListener('click', showMainMenu);
    pipesToggle.addEventListener('click', togglePipes);
    pipeSpacingInput.addEventListener('change', updatePipeSettings);
    pipeSpacingInput.addEventListener('input', updatePipeSettings);
    pipeGapInput.addEventListener('change', updatePipeSettings);
    pipeGapInput.addEventListener('input', updatePipeSettings);
    pipeSpeedInput.addEventListener('change', updatePipeSettings);
    pipeSpeedInput.addEventListener('input', updatePipeSettings);
    livesInput.addEventListener('change', updateLives);
    livesInput.addEventListener('input', updateLives);
    ghostDurationInput.addEventListener('change', updateGhostDuration);
    ghostDurationInput.addEventListener('input', updateGhostDuration);
    resetHighscoreBtn.addEventListener('click', resetHighscore);
    resetSettingsBtn.addEventListener('click', resetAllSettings);
    
    // Close menu modal when clicking outside
    menuModal.addEventListener('click', (e) => {
      if (e.target === menuModal) {
        hideMenu();
      }
    });
    
    document.getElementById('soundBtn').addEventListener('click', () => {
      SoundManager.toggle();
    });

    // Controls
    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      mouseHeld = true;
      startJump();
    });
    canvas.addEventListener('mouseup', (e) => {
      e.preventDefault();
      mouseHeld = false;
    });
    canvas.addEventListener('mouseleave', (e) => {
      mouseHeld = false;
    });
    // Two-finger tap detection for pause/play
    let twoFingerTapStartTime = 0;
    let twoFingerTapStartTouches = 0;
    
    canvas.addEventListener('touchstart', (e) => {
      // Check for two-finger tap
      if (e.touches.length === 2) {
        twoFingerTapStartTime = performance.now();
        twoFingerTapStartTouches = 2;
        e.preventDefault();
        return;
      }
      
      // Single touch - normal jump behavior
      if (e.touches.length === 1 && twoFingerTapStartTouches !== 2) {
        e.preventDefault();
        mouseHeld = true;
        startJump();
      }
    }, { passive: false });
    
    canvas.addEventListener('touchend', (e) => {
      // Check if this was a two-finger tap
      if (twoFingerTapStartTouches === 2 && e.touches.length === 0) {
        const tapDuration = performance.now() - twoFingerTapStartTime;
        // If both fingers lifted within 300ms, it's a tap (not a drag)
        if (tapDuration < 300) {
          e.preventDefault();
          togglePause();
        }
        twoFingerTapStartTouches = 0;
        twoFingerTapStartTime = 0;
        return;
      }
      
      // Single touch end
      if (e.touches.length === 0) {
        e.preventDefault();
        mouseHeld = false;
      }
    }, { passive: false });
    
    canvas.addEventListener('touchcancel', (e) => {
      twoFingerTapStartTouches = 0;
      twoFingerTapStartTime = 0;
      mouseHeld = false;
    }, { passive: false });

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'gameover') {
          // Restart game when gameover
          restartGame();
        } else if (!spaceHeld) {
          spaceHeld = true;
          startJump();
        }
      } else if (e.code === 'Enter') {
        e.preventDefault();
        if (gameState === 'playing' || gameState === 'paused') {
          togglePause();
        }
      } else if (e.code === 'Escape') {
        e.preventDefault();
        if (menuModal.classList.contains('show')) {
          hideMenu();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        spaceHeld = false;
      }
    });

    // Initialize pause button
    updatePauseButton();

    // Load settings
    loadSettings();

    // Initialize high score display on page load
    highscoreEl.textContent = highscore;

    // Start game loop
    gameLoop();
  </script>
</body>
</html>
